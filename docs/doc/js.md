> #### Promise

Promise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决方案（回调函数和事件）更合理和更强大。
ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。

promise是为解决异步处理回调金字塔问题而产生的

1. Promise对象的状态不受外界影响
   
    Promise 有以上三种状态，只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个状态

    - pending 初始状态
    - fulfilled 成功状态
    - rejected 失败状态
  
2. Promise的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆，只能由 pending变成fulfilled或者由pending变成rejected

> #### call和apply

Call和apply作用一摸一样，只是传参的形式有区别

   * call 参数不定
      - 函数上下文的对象
      - 参数列表

   * apply 2个参数
      - 函数上下文的对象
      - 函数参数组成的数组
   
1. 改变了this的指向
2. 借用别的对象的方法
3. 调用函数，apply、call方法会使函数立即执行

> #### 前端模块化

- 将一个复杂的程序依据一点的规则(规范)封装成几个块，并进行组合在一起
- 快的内部数据与实现是私有的，只是向外部暴漏一些接口(方法)与外部其他模块通信

> #### 延迟加载JS有哪些方式？

- async ：async和html加载是同步的， 不是顺次执行js脚本（谁先加载完先执行谁）。
- defer ： html解析完毕后执行代码。

> #### js数据类型

- **基本类型：** string、boolean、undefined、null、symbol、bight
- **引用类型：** object
    - NaN是数值类型，但是不一个数字
    
> #### null和undefined区别

- null：作者借鉴了java设计了null，表示一个无的对象；
- undefined：表示一个无的值，为了填坑；

    
> #### ==和===的区别

- **==**： 比较的是值，比较的时候会隐身转换，用valueOf()方法。
- **===**： 不但比较值，而且比较类型。

> #### 微任务和宏任务

- js是单线程的
- js代码执行流程：同步任务执行完毕 =》 事件循环
    - 事件循环：
        - 微任务：promise、then
        - 宏任务：setTimeout..  
        **要执行宏任务的前提是提前清空了微任务**  
        **同步 => 事件循环 => 【微任务，宏任务】=> 微任务 => 宏任务 =>微任务...**

> #### js作用域

- 除了函数之外，js是没有块级作用域；
- 作用域链，内部可以访问外部的变量，但是外部不能访问内部变量，依次从内向外查找变量；
- 注意：声明变量是var还是没写（window）；
- 注意：js有变量提升机制；
- 优先级：声明变量 > 声明普通函数 > 参数 > 变量提升

> #### js对象

- 对象是通过new操作符构建出来的，所以对象之间不相等；
- 对象注意：引用类型；
- 对象的key都是字符串类型；
- 对象如何找属性/方法
    - (原型链)先在对象本身找 => 构造函数中找 => 对象原型中找 => 构造函数原型中找 => 对象上一层原型查找...
    - 每一个函数都自带一个prototype[原型] 注意：对象拥有_proto_属性
    - new Fun：该Fun构造函数的原型指向于对象（new Fun）的原型

> #### new操作符具体做了什么？

- 创建了一个空的对象；
- 将空对象的原型，指向构造函数的原型；
- 将空对象作为构造函数的上下文（改变this指向）；
- 对构造函数有返回值的处理判断；

> #### 闭包

- **闭包是什么？**
    - 闭包是一个函数加上到创建函数的作用域的连接，闭包“关闭”了函数的自由变量。
- **闭包可以解决什么问题（优点）**
    - 1.内部函数可以访问到外部函数的局部变量；
    - 2.闭包可以解决的问题（嵌套函数以解决变量销毁）
- **闭包的缺点**
    - 变量会驻留在内存中，造成内存损耗问题。
        - 解决：将闭包的函数设置为null
    - 内存泄漏 （ie浏览器）

> #### 原型链

- 原型可以解决什么问题 
    - 对象共享属性和共享方法
- 谁有原型？
    - 函数拥有 prototype
    - 对象拥有  _proto_
- 原型链是什么？
    - 先在对象本身找 => 构造函数中找 => 对象原型中找 => 构造函数原型中找 => 对象上一层原型查找
    - 就是吧原型串联起来
    - 原型链的最顶端是null

> #### js继承方式

- 方式一：es6继承方式 extends super();
- 方式二：原型链继承 Child.prototype = new Parent();
- 方式三：构造函数继承；
- 方式四：组合式继承；